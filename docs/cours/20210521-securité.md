# Sécurité

Mega important

1. prepare sql - injection sql
1. validation formulaire front (expression rationnelles, type input...)
1. validation formulaire back (expressions rationnelles, escapespecialchars, contrôle des types, type des fichiers acceptés ...)
1. .env / constantes config pour ne pas commiter d'infos secrètes
1. paramétrer serveur web pour limiter les accès à certains fichiers
1. upload fichier : utiliser les mime/type pour vérifier le fichier => changer l'extension , changer le nom (uniqid) du fichier pour éviter un accès illégitime (ex : facebook `photos/ghuierg/iurhiure/frehrehreiheirghirehg.jpg`)
1. hashage de mot de passe (=> non hashé => **prison**)
1. code de qualité pour éviter les bugs (tests unitaires, tests de bout en bout ...)
1. Veille technologique, validation/tests de la qualité des urls/partenaires tierces (cf RGPD : responsabilité des fournisseurs _et_ des clients parfois)
1. RGPD : un DPO, un référentiel des traitements de données, la possibilité de fournir à un utilisateur toutes ses données (et comment on les utilise), supprimer ses données s'il le demande ou les exporter s'il le demande
1. https !
1. chiffrement des données
1. csrf : cross site request forgery
1. xss : cross site scripting
1. CORS : cross origin resource sharing

## Chiffrement / hashage

### Cryptage / décryptage / codage / décodage

Illisible. 

### Chiffrement

Partager un secret pour que les seules personnes qui connaissent le secret puissent lire le message.

> important : "Reversibilité" : je peux chiffrer et déchiffrer

exemples : A-vaut-K, RSA, ECDSA, ED25519 ...

RSA, ECDSA, ED25519 etc. sont des chiffrements asymétriques : avec une clé publique et une clé privée. (cf connexion à github : `ssh-keygen` pour éviter de taper son login mdp à chaque fois)

### Hachage (hash in english)

Notamment les mots de passe.

C'est quoi ?

> Rend illisible le même message de la même manière, **sans réversibilité**.

Hachage , mais pas "déhachage" (penser au steak).

Pour les BDD de mots de passe, si j'utilisais du chiffrement, la récupération de la clé secrète permettrait d'avoir accès à la liste de tous les mots de passe en clair.

#### Attaque contre la base hachée

Brute force: je calcule un tableau de correspondance entre tous les mots qui existent et les hash.

ex: azerty => ozhfloihdsfhfdvhvgfd

On a eu qques années de protection, mais aujourd'hui on peut trouver des tableaux pré-calculés de hashs de mdp !

#### Protection du moment : le Salt (le grain de sel)

Le but : augmenter artificiellement la taille du mdp pour lutter contre l'augmentation de la puissance de calcul des hackers.

1. inscription :
  * user => "toto" (4 caractères, bof)
  * app => `concat("toto" , 256 caractères au pif (salt))`
  * app => hash ce mdp (de 260 caractères)

2. connexion :
  * user => "toto"
  * app => `concat("toto" , avec les mêmes 256 caractères (stockés en clair dans ma bdd))`
  * app => password verify

Je suis protégé tant que les attaquants n'ont pas le tableau des mdp >= 260 caractères.

Pour éviter qu'un attaquant calcule le tableau (qui n'existe pas encore) uniquement pour mon salt => ce qui revient à calculer le tableau pour les 8 caractères classiques ! donc c'est pas très long.

=> astuce : un salt différent par utilisateur !

### https (ssl)

HTTP : protocole de communication entre machines sur internet.

> Analogie (un peu bancale) : http = description de comment envoyer un courrier à un destinataire (càd: enveloppe + adresse + timbre + exp ...)

=> est-ce que mon courier est protégé ? NON ! on peut ouvrir la lettre et la lire !

idem pour http : si je fais `POST mabanqueprivee.com {identifiant: "pierre99", mdp: "j'adore le code"}` alors n'importe quel équipement réseau qui peut lire les échanges HTTP peut lire votre login/mdp.

> l'idée du https est de chiffrer le contenu de ta requete http ! comme si tu mettais dans ton enveloppe un message codé.

1. le site me passe sa clé publique
2. j'utilise sa clé pour chiffrer ma demande (et lui envoyer ma clé publique en meme temps)
3. je lui envoie (et personne ne peut la lire)
4. le site déchiffre ma demande etc. et me répond en chiffrant avec ma clé publique + sa clé privée !

NB: pour vous : soit acheter un "certificat" à votre hébergeur (ovh, gandi...), soit utiliser letsencrypt.org qui fournit des certificats gratuits.

## Injection SQL



## CSRF : Cross Site Request Forgery

## XSS : Cross Site Scripting

## CORS : Cross Origin Resource Sharing

## RGPD : Règlement Général de Protection des Données (GDPR)
